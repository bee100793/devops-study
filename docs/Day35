# 📅 Day 3: 죽은 서버 살려내기 (Self-Healing Automation)

> **학습 날짜:** 2026.02.05  
> **핵심 주제:** 서비스 상태 점검, 종료 코드(`$?`), 그리고 자동 복구 로직 구현

---

## 🎯 학습 목표
1. **서버 감시:** 사람이 자고 있을 때도 스크립트가 Nginx 서버의 생사를 확인한다.
2. **자가 치유 (Self-Healing):** 서버가 꺼져있다면 관리자의 개입 없이 자동으로 재시작(`restart`)시킨다.
3. **환경 대응:** `systemctl` 사용이 제한된 환경(WSL)에서 `service` 명령어로 유연하게 대처한다.

---

## 💻 실습 코드: `monitor.sh`

꺼져있는 Nginx를 감지하고, 다시 켜고, 확인까지 하는 완전 자동화 스크립트입니다.

#!/bin/bash

SERVICE="nginx"

echo "=== ${SERVICE} 모니터링 시작 ==="

# 1. 서비스 상태 확인
# > /dev/null : "말이 너무 많으니 결과 화면은 버리고(숨기고), 성공/실패 여부만 알려줘"
sudo service ${SERVICE} status > /dev/null




# 2. 종료 코드($?) 확인
# 리눅스에서는 0이 '정상(Success)', 0이 아니면 '에러(Fail)'
# -ne 0 : 0과 같지 않다면 (= 꺼져있다면)
if [ $? -ne 0 ]; then
    echo "🚨 비상! ${SERVICE}가 꺼져있습니다."
    echo "시스템을 복구합니다..."

    # 3. 서비스 재시작 (심폐소생술)
    sudo service ${SERVICE} start
    
    # [중요] 레이스 컨디션 방지
    # 명령 내리자마자 확인하면 아직 로딩 중이라 '실패'로 뜰 수 있음. 2초 대기.
    sleep 2

    # 4. 복구 결과 재확인
    sudo service ${SERVICE} status > /dev/null
    if [ $? -eq 0 ]; then
        echo "✅ ${SERVICE}가 성공적으로 재실행되었습니다."
    fi

else
    echo "👍 ${SERVICE}가 정상 작동 중입니다."
fi
💡 핵심 개념 정리 (Today's Key Learnings)
1. 리눅스의 반전 세계관: 0이 왕이다 👑
일반 프로그래밍과 달리, 쉘 스크립트(시스템)에서는 **0이 '성공(Success)'**을 의미한다.

이유: 성공하는 경우는 하나(완벽함)지만, 실패하는 이유는 수만 가지(에러 코드 1, 2, 3...)기 때문.

Exit Code 0 → 정상

Exit Code 1~255 → 에러

             
2. 쓰레기통 > /dev/null
스크립트 실행 중 불필요한 로그 텍스트가 화면을 덮는 것을 방지한다.

오직 **로직(성공/실패)**에만 집중하기 위해 사용한다.

위치: 명령어 바로 뒤에 붙여야 함. (예: 명령어 > /dev/null)

             
3. 잠시 멈춤 sleep
컴퓨터의 속도는 너무 빠르고, 프로그램 구동에는 시간이 걸린다.

명령어를 내리고 결과를 확인하기 전에 물리적인 시간(텀)을 주는 것이 버그를 줄이는 비결이다.

🛠️ 트러블 슈팅 (Troubleshooting)
문제 상황 (Issue)
WSL(Windows Subsystem for Linux) 환경에서 표준 명령어인 systemctl을 사용했으나 PID 1 관련 에러 발생.

해결 과정 (Solution)
/etc/wsl.conf 설정을 변경하여 해결하려 했으나 환경 특성상 불안정함.

유연한 대처: 구형 명령어지만 WSL에서 완벽하게 호환되는 service 명령어로 로직을 변경함.

결과: systemctl is-active 대신 service status + $?(종료 코드) 조합을 사용하여 동일한 기능 구현 성공.



