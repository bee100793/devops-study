[Log 분석-데이터 탐색 "grep 으로 에러 찾기"]

1.. 정밀 검색과 논리 연산 (-w, -E, |)
원하는 단어를 정확히 찾거나, 여러 조건을 걸 때 사용한다.

-w (Word): 정확히 그 단어만 검색 (예: 'error' 검색 시 'noerror'는 제외)

-E (Extended Regex): 정규표현식 사용 (OR 연산 | 가능)

| (Pipe): 명령어 연결 (AND 연산 효과)

2. 대량 파일 분석 (-l, -r, --include)
파일이 수백 개일 때, "어느 파일"에 문제가 있는지 찾는다.

-l (List): 내용은 보여주지 말고, 단어가 포함된 파일 이름만 출력

-r (Recursive): 하위 디렉토리까지 모두 뒤짐

--include: 특정 파일 패턴만 검색 대상에 포함

3. 문맥(Context) 확인 (-C, -A, -B)
에러 메시지 한 줄만 봐서는 원인을 모를 때 사용한다.

-C n: 위아래 n줄씩 더 보여줌 (Context)

-A n: 아래(After)로 n줄 더 보여줌

-B n: 위(Before)로 n줄 더 보여줌

🛠️ 실무 트러블 슈팅 (Troubleshooting)
상황 1: 실시간 로그 감시 시 딜레이 발생
문제: tail -f server.log | grep "ERROR"를 했는데, 에러가 발생해도 화면에 바로 안 뜸.
원인: 리눅스의 버퍼링(Buffering) 때문에 데이터가 어느 정도 찰 때까지 grep이 출력을 안 하고 기다림.
해결: --line-buffered 옵션 사용 (한 줄 들어오면 즉시 뱉어라!)

상황 2: grep 명령어가 멈춘 것처럼 보일 때
문제: grep "ERROR" 라고 쳤는데 커서만 깜빡이고 아무 반응이 없음.
원인: 어디서(파일) 찾을지를 입력하지 않았음. grep은 사용자의 키보드 입력을 기다리는 상태(Stdin)가 됨.
해결: 뒤에 파일명이나 와일드카드(*)를 반드시 붙여준다.

🚀 오늘의 결론 (Insight)
grep은 단순 검색기가 아니다. -v(제외)나 -E(논리 연산)를 활용하면 강력한 **"데이터 정제 도구"**가 된다.

터미널에서 grep으로 데이터를 1차 가공하는 능력은 자동화 스크립트 작성의 기초가 된다.
