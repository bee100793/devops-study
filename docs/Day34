# 📅 Day 33: 쉘 스크립트 조건문 (if) 정복하기 
> **핵심 주제:** 조건문(`if`)을 활용한 흐름 제어와 방어적 코딩 (Defensive Coding)

1. if 기본 구조

if [ 조건 ]; then
    # 조건이 참일 때 실행
elif [ 다른조건 ]; then
    # 다른 조건이 참일 때 실행
else
    # 모두 아닐 때 실행
fi  # if를 거꾸로 한 fi로 닫아줌!


2. if 조건문의 '주의 사항'
-대괄호 [ ] 사이의 공백은 필수!
if [$A == $B] (X) -> 에러 발생

if [ $A == $B ] (O) -> 반드시 양 끝에 한 칸씩 띄워야 함.

-변수는 항상 따옴표 "$ "로 감싸기!
if [ $1 == "bee" ] 라고 썼는데 $1이 비어있으면 에러남.

if [ "$1" == "bee" ] 처럼 감싸줘야 한다.

-then의 위치
if [ 조건 ] 바로 다음 줄에 then을 쓰거나, 같은 줄에 쓰고 싶으면 ;를 붙여야 함. (if [ ]; then)



3. 가장 많이 쓰는 '조건 옵션'
파일/폴더 체크:

-d 폴더명: 폴더(Directory)가 존재하면 참

-f 파일명: 일반 파일(File)이 존재하면 참

-e 이름: 파일이든 폴더든 존재만 하면 참

문자열 체크:

-z "문자열": 문자열 길이가 0이면(비어있으면) 참 (파라미터 $1 체크할 때 필수!)

-n "문자열": 문자열이 비어있지 않으면 참

"$A" == "$B": 두 문자가 같으면 참

숫자 비교 :

-gt: 크다 (Greater Than)

-lt: 작다 (Less Than)

-ge: 크거나 같다

-le: 작거나 같다

-eq: 같다 (Equal)



4 .오늘의 트러블 슈팅 
1. unexpected EOF 에러
원인: 변수나 문자열을 감싸는 따옴표(")의 짝이 맞지 않아서 발생.

해결: if [ "${answer}" == "y" ]; 처럼 열고 닫는 따옴표 개수(4개)를 정확히 맞춤.

2. 논리 오류 (Logic Error)
현상: 백업을 완료했는데도 마지막에 "파일이 없습니다"라는 메시지가 또 출력됨.

원인: 바깥쪽 if문에 else 처리를 하지 않아서, 코드가 끝까지 실행되어버림.

해결: 파일이 없을 때만 실행되도록 else 구문을 명확히 추가하여 흐름을 분리함.



-------------------------------------------------------------------------------------------


## 💻 실습 코드: 안전한 백업 스크립트 (`if_backup.sh`)

사용자가 백업을 원할 때만(`y`), 그리고 파일이 실제로 존재할 때만 동작하는 스마트한 스크립트입니다.

```bash
#!/bin/bash

# 1. 대상 파일 지정
FILENAME="aaa.log"

# 2. 파일 존재 여부 확인 (1차 검문)
# [ -f 파일명 ] : 파일이 존재하면 참(True)
if [ -f "${FILENAME}" ]; then
    
    # 3. 사용자 의사 확인 (-n 옵션은 줄바꿈 방지)
    echo -n "${FILENAME} 파일이 존재합니다. 백업을 할까요? (y/n): "
    read answer

    # 4. 답변에 따른 분기 처리 (2차 검문)
    # 문자열 비교는 == 를 사용하며, 변수는 따옴표로 감싸는 것이 안전함
    if [ "${answer}" == "y" ]; then
        echo "백업을 진행합니다..."
        
        # tar 옵션: c(생성), z(gzip압축), v(과정출력), f(파일명지정)
        # 전체를 따옴표로 감싸서 파일명에 공백이 있어도 에러 방지
        tar -czvf "backup_${FILENAME}.tar.gz" "${FILENAME}"
        
        echo "백업 완료!"
    else
        echo "백업을 취소했습니다."
    fi

else
    # 5. 파일이 없을 경우 예외 처리 (Logic Fall-through 방지)
    echo "⚠️ 오류: ${FILENAME} 파일이 없습니다."
fi


2. 파일/변수 검사 옵션 (실무 필수)
데이터를 처리하기 전, 입구에서 문제를 걸러내는 옵션들을 학습함.

-z "$VAR" (Zero): 변수가 비어있는지(글자수가 0인지) 확인. 파라미터 $1 입력 여부 체크에 필수.

-d "$VAR" (Directory): 대상이 실제 존재하는 폴더인지 확인.

-e "$VAR" (Exists): 대상이 존재하는지 확인 (파일/폴더 구분 없음).

! (NOT): 조건을 반대로 뒤집음. (예: ! -d는 "폴더가 아니라면"이라는 뜻)

3. Early Exit (else 대신 exit 1)
코드가 복잡해지는 if-else 미로 대신, 에러를 발견하자마자 스크립트를 종료하는 방식을 학습함.

exit 1: "문제가 생겼으니 여기서 당장 멈춰!"라는 신호를 컴퓨터에 전달.

장점: 본론(압축 등 메인 로직)이 들여쓰기 없이 깔끔하게 유지되어 가독성이 높아짐.

4. 실습 결과물: 지능형 백업 스크립트 (v2.0)
사용자의 실수(입력 누락, 오타)를 스스로 판단하여 안내하는 완성형 스크립트.

Bash
#!/bin/bash

# 1. 변수 설정
target=$1
today=$(date +%Y-%m-%d_%H%M)

# 2. 1차 검문: 이름표를 가져왔는가? (글자수 체크)
if [ -z "$target" ]; then
    echo "🚨 에러: 백업할 대상 이름을 적어주세요!"
    echo "사용법: $0 [폴더명]"
    exit 1
fi

# 3. 2차 검문: 실제 폴더가 서버에 있는가? (존재 여부 체크)
if [ ! -d "$target" ]; then
    echo "🚨 에러: '$target' 폴더를 찾을 수 없습니다. 오타를 확인하세요."
    exit 1
fi

# 4. 본론: 검문을 통과한 데이터만 압축 진행
FILENAME="backup_${target}_${today}.tar.gz"

# 홈 디렉토리로 이동하여 안전하게 저장
cd ~
tar -czvf ${FILENAME} ${target}

echo "✅ 백업 완료: ${FILENAME}"
5. 오늘의 깨달음 (Troubleshooting)
파일 위치의 비밀: 스크립트 안에 cd ~가 있으면, 어디서 실행하든 파일은 홈 디렉토리에 생성된다. 파일이 안 보일 땐 pwd와 스크립트 내 경로를 확인하자.

정교한 타겟팅: -e보다 -d를 사용하는 것이 "폴더를 백업한다"는 목적에 더 부합하며, 의도치 않은 파일 압축을 방지할 수 있다.

프로의 습관: 에러 메시지를 구체적으로 적어주면(-z일 때와 -d일 때를 구분), 나중에 나뿐만 아니라 동료들도 문제를 쉽게 파악할 수 있다.



